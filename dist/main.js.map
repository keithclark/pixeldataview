{"version":3,"file":"main.js","sources":["../src/lib/assert.js","../src/lib/ChunkyPixelDataView.js","../src/lib/PlanarPixelDataView.js"],"sourcesContent":["/**\n * Helper for throwing an error\n * \n * @param {Error} errorType the value to format\n * @param {string} message Description of the error\n * @param {string} [context] Optional context for the error\n */\nconst raiseError = (errorType, message, context) => {\n  if (context) {\n    message = context + '. ' + message;\n  }\n  throw new errorType(message);\n};\n\n\n/**\n * Helper for throwing an assertion error\n * \n * @param {Error} errorType the value to format\n * @param {string} expectation Description of the expected outcome\n * @param {string} actual Description of the actual outcome\n * @param {string} [context] Optional context for the error\n */\nconst raiseUnexpectedError = (errorType, expectation, actual, context) => {\n  if (Array.isArray(expectation)) {\n    expectation = conjuction(expectation);\n  }\n  raiseError(\n    errorType,\n    `Expected ${expectation}, got ${actual}.`,\n    context ? `Invalid ${context}` : context\n  );\n};\n\n\n/**\n * Formats a value into a readable string representation.\n * \n * @param {*} value the value to format\n * @returns {string} The formatted value\n */\nconst formatValue = (value) => {\n  if (typeof value === 'string') {\n    return `\"${value}\"`;\n  } \n  return value;\n};\n\n\n/**\n * Combines an array of values into a sentence.\n * \n * @param {string[]} values \n * @returns {string}\n */\nconst conjuction = (values) => {\n  if (values.length < 2) {\n    return values[0];\n  }\n  return `${values.slice(0, -1).join(', ')} or ${values.at(-1)}`;\n};\n\n\n/**\n * Ensures a value is within a given range.\n * \n * @param {number} value The value to check\n * @param {number} min The minimum allowed value \n * @param {number} max The maximum allowed value \n * @param {string} message Message to include in the assertion error\n * @throws {RangeError}\n */\nexport const assertBetween = (value, min, max, message = 'Invalid value') => {\n  if (value < min || value > max) {\n    raiseUnexpectedError(\n      RangeError,\n      `between ${min} and ${max}`,\n      value,\n      message\n    );\n  }\n};\n\n\n/**\n * Ensures a value is an instance of one or more objects.\n * \n * @param {*} value The value to check \n * @param {Object[]} types The object types to checkfor\n */\nexport const assertInstance = (value, types, message) => {\n  if (!types.some((type) => value instanceof type)) {\n    raiseUnexpectedError(\n      TypeError,\n      types.map(v => v.name),\n      typeof value,\n      message\n    );\n  }\n};\n\n\n/**\n * Ensures a value is of a given type.\n * \n * @param {*} value The value to check \n * @param {string[]} types The allowed type names (e.g `string` or `boolean`)\n */\nexport const assertType = (value, types, message) => {\n  if (!types.includes(typeof value)) {\n    raiseUnexpectedError(\n      TypeError,\n      types,\n      typeof value,\n      message\n    );\n  }\n};\n\n\n/**\n * Ensures a value matches one of a given list of values\n * \n * @param {*} value The value to check \n * @param {[]} values The allowed values\n */\nexport const assertOneOf = (value, values, message) => {\n  if (!values.includes(value)) {\n    raiseUnexpectedError(\n      RangeError,\n      values.map(formatValue),\n      formatValue(value),\n      message\n    );\n  }\n};\n","import { assertBetween, assertInstance, assertType } from \"./assert.js\";\n\n/**\n * `ChunkyPixelDataView` exposes a low-level interface for reading and writing \n * individual pixel values in chunky-encoded image data, stored in an \n * `ArrayBuffer`.\n * \n * @example\n * import { ChunkyPixelDataView } from '@keithclark/pixeldataview';\n * \n * const imageData = new ImageData(16, 16);\n * const pixelView = new ChunkyPixelDataView(imageData.data.buffer, 16, 16);\n * \n * // Set pixel at 7, 7 to orange\n * pixelView.setColor(7, 7, 0xffcc00ff);\n * \n * // Get the pixel color at 7, 7\n * let color = pixelView.getColor(7, 7);\n */\nexport default class ChunkyPixelDataView {\n\n  /** @type {DataView} */\n  #view;\n \n  /** @type {number} */\n  #width;\n\n  /** @type {number} */\n  #height;\n\n  /**\n   * Creates a new `ChunkyPixelDataView` instance.\n   * \n   * @param {ArrayBuffer|SharedArrayBuffer} buffer An existing buffer containing the image data\n   * @param {number} width The width of the image data in bytes\n   * @param {number} height The height of the image data in scanlines\n   * @param {number} [byteOffset] An optional offset, in bytes, to the first byte in the buffer containing the image data.\n   */\n  constructor(buffer, width, height, byteOffset=0) {\n    assertBetween(arguments.length, 3, 4, 'argument count');\n    if ('SharedArrayBuffer' in globalThis) {\n      assertInstance(buffer, [ArrayBuffer, SharedArrayBuffer]);\n    } else {\n      assertInstance(buffer, [ArrayBuffer]);\n    }\n    assertType(width, ['number'], 'width');\n    assertType(height, ['number'], 'height');\n    this.#view = new DataView(buffer, byteOffset, width * height * 4);\n    this.#width = width;\n    this.#height = height;\n  }\n\n\n  /**\n   * Gets the color of a pixel at the given coordinates\n   * \n   * @param {number} x Horizontal position (x coordinate) of the pixel to check\n   * @param {number} y Vertical position (y coordinate) of the pixel to check\n   * @returns {number} The color of the pixel as a unsigned 32-bit integer\n   * @throws {RangeError} if `x` or `y` are outside the image bounds\n   */\n  getColorAt(x, y) {\n    assertBetween(x, 0, this.#width, 'x');\n    assertBetween(y, 0, this.#height, 'y');\n    return this.#view.getUint32((y * this.#width + x) << 2);\n  }\n\n\n  /**\n   * Set the color of a pixel at the given coordinates\n   * \n   * @param {number} x Horizontal position (x coordinate) of the pixel to set\n   * @param {number} y Vertical position (y coordinate) of the pixel to set\n   * @param {number} color The new color for the pixel as a unsigned 32-bit integer\n   * @throws {RangeError} if `x` or `y` are outside the image bounds, or if `color` isn't suitable for the number of planes\n   */\n  setColor(x, y, color) {\n    assertBetween(x, 0, this.#width, 'x');\n    assertBetween(y, 0, this.#height, 'y');\n    this.#view.setUint32((y * this.#width + x) << 2, color);\n  }\n\n}\n","import { assertBetween, assertInstance, assertOneOf, assertType } from \"./assert.js\";\n\nconst INTERLEAVE_FORMAT_WORD = 'word';\n\nconst INTERLEAVE_FORMAT_LINE = 'line';\n\nconst INTERLEAVE_FORMAT_CONTIGUOUS = 'contiguous';\n\n\n/**\n * `PlanarPixelDataView` exposes a low-level interface for reading and writing \n * individual pixel values in planar-encoded image data, stored in an \n * `ArrayBuffer`. Three planar encoding formats are supported: line-interleaved,\n * word-interleaved and contiguous.\n */\nexport default class PlanarPixelDataView {\n\n  /** @type {Uint8Array} */\n  #view;\n \n  /** @type {number} */\n  #width;\n\n  /** @type {number} */\n  #height;\n\n  /** @type {number} */\n  #planes;\n\n  /** @type {(x: number, y: number) => number} */\n  #coordinatesToOffset;\n\n  /** @type {number} */\n  #planeStep;\n\n  /** @type {number} */\n  #maxColors;\n\n  /**\n   * Creates a new `PlanarPixelDataView` instance.\n   *  \n   * @param {ArrayBuffer|SharedArrayBuffer} buffer An existing buffer containing the image data\n   * @param {number} width The width of the image data, in pixels\n   * @param {number} height The height of the image data, in pixels\n   * @param {number} planes The number of bitplanes in the image data\n   * @param {'contiguous'|'line'|'word'} interleave The bitplane interleave format the data is stored in\n   * @param {number} [byteOffset] An optional offset, in bytes, to the first byte in the buffer containing the image data.\n   */\n  constructor(buffer, width, height, planes, interleave=INTERLEAVE_FORMAT_WORD, byteOffset=0) {\n    assertBetween(arguments.length, 4, 6, 'argument count');\n    if ('SharedArrayBuffer' in globalThis) {\n      assertInstance(buffer, [ArrayBuffer, SharedArrayBuffer]);\n    } else {\n      assertInstance(buffer, [ArrayBuffer]);\n    }\n    assertType(width, ['number'], 'width');\n    assertType(height, ['number'], 'height');\n    assertType(planes, ['number'], 'plane count');\n    assertOneOf(interleave, [\n      INTERLEAVE_FORMAT_CONTIGUOUS,\n      INTERLEAVE_FORMAT_LINE,\n      INTERLEAVE_FORMAT_WORD\n    ], 'interleave format');\n\n    let bytesPerLine;\n\n    if (interleave === INTERLEAVE_FORMAT_WORD) {\n      bytesPerLine = Math.ceil(width / 16) * 2;\n      this.#planeStep = 2;\n      this.#coordinatesToOffset = (x, y) => y * bytesPerLine * planes + planes * 2 * (x >> 4) + (x % 16 < 8 ? 0 : 1);\n    } else if (interleave === INTERLEAVE_FORMAT_LINE) {\n      bytesPerLine = Math.ceil(width / 8);\n      this.#planeStep = bytesPerLine;\n      this.#coordinatesToOffset = (x, y) => y * bytesPerLine * planes + (x >> 3);\n    } else if (interleave === INTERLEAVE_FORMAT_CONTIGUOUS) {\n      bytesPerLine = Math.ceil(width / 8);\n      this.#planeStep = bytesPerLine * height;\n      this.#coordinatesToOffset = (x, y) => y * bytesPerLine + (x >> 3);\n    }\n    this.#view = new Uint8Array(buffer, byteOffset, bytesPerLine * height * planes);\n    this.#width = width;\n    this.#height = height;\n    this.#planes = planes;\n    this.#maxColors = 1 << planes;\n  }\n\n\n  /**\n   * Returns the color index of a pixel at the given coordinates\n   * \n   * @param {number} x Horizontal position (x coordinate) of the pixel to check\n   * @param {number} y Vertical position (y coordinate) of the pixel to check\n   * @returns {number} the index of the pixel color\n   * @throws {RangeError} if `x` or `y` are outside the image bounds\n   */\n  getColor(x, y) {\n    assertBetween(x, 0, this.#width, 'x');\n    assertBetween(y, 0, this.#height, 'y');\n    const bitOffset = 0x7 - (x & 0x7);\n    const mask = 1 << bitOffset;\n    let offset = this.#coordinatesToOffset(x, y);\n\n    let color = 0;\n    for (let plane = 0; plane < this.#planes; plane++) {\n      color |= this.#view[offset] & mask ? 1 << plane : 0;\n      offset += this.#planeStep;\n    }\n    return color;\n  }\n\n\n  /**\n   * Set the color index of a pixel at the given coordinates\n   * \n   * @param {number} x Horizontal position (x coordinate) of the pixel to set\n   * @param {number} y Vertical position (y coordinate) of the pixel to set\n   * @param {number} color Index of the new color\n   * @throws {RangeError} if `x` or `y` are outside the image bounds, or if `color` isn't suitable for the number of planes\n   */\n  setColor(x, y, color) {\n    assertBetween(x, 0, this.#width, 'x');\n    assertBetween(y, 0, this.#height, 'y');\n    assertBetween(color, 0, this.#maxColors - 1, 'color');\n\n    const bitOffset = 0x7 - (x & 0x7);\n    const mask = 1 << bitOffset;\n    let offset = this.#coordinatesToOffset(x, y);\n\n    for (let c = 0; c < this.#planes; c++) {\n      if (color & 1) {\n        this.#view[offset] |= mask;\n      } else {\n        this.#view[offset] &= ~mask;\n      }\n      offset += this.#planeStep;\n      color >>= 1;\n    }\n  }\n}\n\n\n"],"names":[],"mappings":"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"}